## 条款19：像设计$type$一样设计$class$

#### 1. 对象的创建和销毁

影响构造函数，析构函数，内存分配函数以及释放函数（见第八章）

#### 2. 对象的初始化和赋值的差别

决定构造函数和赋值操作符的行为和差异（内[条款4](F:\滔天\文件\学校\大学\专业\C++\C++笔记\1.习惯C++\条款04：初始化对象.md))

#### 3. 对象被$passed\ by\ value$的意义

$copy$构造函数是用来定义$pass-by-value$该如何实现

#### 4. 新$type$的合法值

对$class$成员变量而言，通常只有数值集是有效的，而这些决定了$class$需要维护的约束条件，以及其他成员函数必须进行的错误检测，也影响函数抛出的异常

#### 5. 新$type$配合继承图系

如果继承自某些$classes$，就受到这些$classes$设计的束缚，特别是受到“它们的函数是$virtual$或$non-virtual$”的影响（[条款34]()和[条款36]())

如果允许其他$classes$继承你的$class$，则会影响自己声明的函数（尤其是析构函数）是否为$virtual$（[条款7](F:\滔天\文件\学校\大学\专业\C++\C++笔记\2.构造、析构、赋值运算\条款07：为多态基类声明virtual析构函数.md)）

#### 6. 新$type$需要的转换

若需要$T1$隐式转换为$T2$，则需要在$T1$内写一个类型转换函数或在$T2$内写一个可被单一实参调用的构造函数

若只允许$explicit$构造函数存在，则得写出专门负责执行转换的函数，且不得为类型转换操作符或可被单一实参调用的构造函数

（[条款15](F:\滔天\文件\学校\大学\专业\C++\C++笔记\3.资源管理\条款15：在资源管理类中提供对原始资源的访问.md)）

#### 7. 对新$type$合理的操作符和函数

决定你为$class$声明的函数及其是否为成员函数（[条款23]()，[条款24]()，[条款46]()）

#### 8. 需要驳回的标准函数

是被声明为`private​`的函数（[条款6](F:\滔天\文件\学校\大学\专业\C++\C++笔记\2.构造、析构、赋值运算\条款06：拒绝编译器自动生成的函数.md)）

#### 9. 新$type$成员的调用

决定成员是`public`​, `private`还是`protected`，同时也决定哪一个$classes$和/或$functions$应该是$friends$，以及它们互相嵌套的合理性

#### 10. 新$type$的“未声明接口”

需要对效率、异常安全性（[条款29]()）以及资源运用（如多任务锁定和动态内存）提供保证

#### 11. 新$type$的一般化程度

若你想定义一个$type$s大家族，则应该用$class\ template$替代$class$

#### 12. 新$type$的必要性

若只是想定义新的$derived class$为已有$class$添加机能，则还不如定义几个$non-member$函数或$templates$
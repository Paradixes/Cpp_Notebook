## 条款19：像设计type一样设计class

#### 1. 对象的创建和销毁

影响构造函数，析构函数，内存分配函数以及释放函数（见第八章）

#### 2. 对象的初始化和赋值的差别

决定构造函数和赋值操作符的行为和差异（内[条款4](F:\滔天\文件\学校\大学\专业\C++\C++笔记\1.习惯C++\条款04：初始化对象.md))

#### 3. 对象被passed by value的意义

copy构造函数是用来定义pass-by-value该如何实现

#### 4. 新type的合法值

对class成员变量而言，通常只有数值集是有效的，而这些决定了class需要维护的约束条件，以及其他成员函数必须进行的错误检测，也影响函数抛出的异常

#### 5. 新type配合继承图系

如果继承自某些classes，就受到这些classes设计的束缚，特别是受到“它们的函数是virtual或non-virtual”的影响（[条款34]()和[条款36]())

如果允许其他classes继承你的class，则会影响自己声明的函数（尤其是析构函数）是否为virtual（[条款7](F:\滔天\文件\学校\大学\专业\C++\C++笔记\2.构造、析构、赋值运算\条款07：为多态基类声明virtual析构函数.md)）

#### 6. 新type需要的转换

若需要T1隐式转换为T2，则需要在T1内写一个类型转换函数或在T2内写一个可被单一实参调用的构造函数

若只允许explicit构造函数存在，则得写出专门负责执行转换的函数，且不得为类型转换操作符或可被单一实参调用的构造函数

（[条款15](F:\滔天\文件\学校\大学\专业\C++\C++笔记\3.资源管理\条款15：在资源管理类中提供对原始资源的访问.md)）

#### 7. 对新type合理的操作符和函数

决定你为class声明的函数及其是否为成员函数（[条款23]()，[条款24]()，[条款46]()）

#### 8. 需要驳回的标准函数

是被声明为private的函数（[条款6](F:\滔天\文件\学校\大学\专业\C++\C++笔记\2.构造、析构、赋值运算\条款06：拒绝编译器自动生成的函数.md)）

#### 9. 新type成员的调用

决定成员是public, private还是protected，同时也决定哪一个classes和/或functions应该是friends，以及它们互相嵌套的合理性

#### 10. 新type的“未声明接口”

需要对效率、异常安全性（[条款29]()）以及资源运用（如多任务锁定和动态内存）提供保证

#### 11. 新type的一般化程度

若你想定义一个types大家族，则应该用class template替代class

#### 12. 新type的必要性

若只是想定义新的derived class为已有class添加机能，则还不如定义几个non-member函数或templates
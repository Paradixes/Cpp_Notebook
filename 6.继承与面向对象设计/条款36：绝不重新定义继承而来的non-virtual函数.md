# 条款36：不重新定义继承来的 $non$-$virtual$ 函数

## 实务层面

```C++
class B {					//Base class
public:
    void mf();
    ...
};

class D: public B { ... };	//Derived class

D x;			//D类型对象
B* pB = &x;		//获得指针指向x
pB->mf();		//通过该指针调用mf
//异于以下行为
D* pD = &x;		//获得指针指向x
pD->mf();		//通过该指针调用mf
```

+ 两者都通过对象 `x` 调用成员函数 `mf` ，但两者调用函数得行为并不相同

  ```C++
  class D: public B {
  public:
      void mf();			//遮掩了B::mf
      ...
  };
  pB->mf();				//调用B::mf
  pD->mf();				//调用D::mf
  ```

  + $derived\ class$ 中的 `mf` 函数遮掩了 $base\ class$ 得 `mf` 函数（[条款33](条款33：避免遮掩继承而来的名称.md)）
  + 而由于 $non$-$virtual$ 函数是静态绑定（[条款37]()），通过 `pB` 调用的 $non$-$virtual$ 函数，即使 `pB` 指向一个类型为 “`D` 诞生之 `class`” 的对象

  + $virtual$ 函数是动态绑定（[条款37]()），所以它们不会受此影响，$virtual$ 函数不论通过 `pB` 还是 `pD` 调用，都会导致调用 `D::mf` ，因为 `pB` 和 `pD` 真正都是一个类型为 `D` 的对象



## 理论层面

+ 理论基础
  + 适用于 `B` 对象的每一件事，也适用于 `D` 对象，因为每个 `D` 对象都是一个 `B` 对象（[条款32](条款32：确定public继承塑模出is-a关系.md)）
  + `B` 的 $derived\ classes$ 一定继承 `mf` 的接口和实现，因为 `mf` 是 `B` 的一个 $non$-$virtual$ 函数（[条款34](条款34：区分接口继承和实现继承.md)）

+ 矛盾
  + 若 `D` 需要实现与 `B` 不同的 `mf`，并且必须使用 `B` 所提供的 `mf` 实现码，则不符合 "$is$-$a$" 原则
  + 如果 `D` 有需求实现出与 `B` 不同的 `mf` ，那么 `mf` 就无法为 `B` 反映出 “不变性凌驾于特异性” 的性质
+ 多态性的 $base\ classes$ 的析构函数必须是 $virtual$ 函数（[条款7](F:\滔天\文件\学校\大学\专业\C++\C++笔记\2.构造、析构、赋值运算\条款07：为多态基类声明virtual析构函数.md)）便是遵守了这一准则，若违背条款7则是违背这一准则


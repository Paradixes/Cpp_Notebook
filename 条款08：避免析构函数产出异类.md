## 条款08：避免析构函数产出异类

### 一、 析构函数的调用

```C++
class Widget {
public:
    ...
    ~Widget( ) { ... }
};
void doSomething()
{
    std::vector<Widget> v;
    ...
}							//v在此处被销毁
```



### 二、 析构函数的异常

```C++
class DBConnection {				//负责数据库连接
public:
    ...
    static DBConnection create();	//这个函数返回DBConnection对象
    void close();					//关闭联机，失败则抛出异常
};
```

资源管理class：

```C++
class DBConn {
public:
    ...
    ~DBConn()					//确保数据库总是会被关闭
    {
		db.close();				//如果close抛出异常，DBConn析构函数会传播异常
    }
private:
    DBConnection db;
};
```



### 三、 解决异常的两种方法

### 1. 调用abort，强迫结束程序

```C++
DBConn::~DBConn( )
{
    try{ db.close(); }
    catch (...) {
        ...						//制作运转记录，记下对close的调用失败
        std::abort( );
    }
}
```

### 2. 吞掉异常，仅记下异常信息

```C++
DBConn::~DBConn( )
{
    try{ db.close(); }
    catch (...) {
        ...						//制作运转记录，记下对close的调用失败
    }
}
```



### 四、 将风险的处理机会交给客户

```C++
class DBConn {
public:
    ...
    void close()						//供客户使用的新函数
    {
        db.close();
        closed = true;
    }
    ~DBConn()
    {
        if (!closed) {					//如果客户不关闭连接，则自动关闭连接
            try{ db.close(); }
            catch (...) {
                ...						//制作运转记录，记下对close的调用失败
                ...						//吞下或不吞下异常
            }
        }
    }
private:
    DBConnection db;
    bool closed;
};
```

